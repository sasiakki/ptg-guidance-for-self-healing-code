"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileAssetHandler = void 0;
const fs_1 = require("fs");
const path = require("path");
const cloud_assembly_schema_1 = require("@aws-cdk/cloud-assembly-schema");
const mime = require("mime");
const progress_1 = require("../../progress");
const archive_1 = require("../archive");
const fs_extra_1 = require("../fs-extra");
const placeholders_1 = require("../placeholders");
const shell_1 = require("../shell");
class FileAssetHandler {
    constructor(workDir, asset, host) {
        this.workDir = workDir;
        this.asset = asset;
        this.host = host;
        this.fileCacheRoot = path.join(workDir, '.cache');
    }
    async publish() {
        const destination = await placeholders_1.replaceAwsPlaceholders(this.asset.destination, this.host.aws);
        const s3Url = `s3://${destination.bucketName}/${destination.objectKey}`;
        const s3 = await this.host.aws.s3Client(destination);
        this.host.emitMessage(progress_1.EventType.CHECK, `Check ${s3Url}`);
        const bucketInfo = BucketInformation.for(this.host);
        // A thunk for describing the current account. Used when we need to format an error
        // message, not in the success case.
        const account = async () => { var _a; return (_a = (await this.host.aws.discoverTargetAccount(destination))) === null || _a === void 0 ? void 0 : _a.accountId; };
        switch (await bucketInfo.bucketOwnership(s3, destination.bucketName)) {
            case BucketOwnership.MINE:
                break;
            case BucketOwnership.DOES_NOT_EXIST:
                throw new Error(`No bucket named '${destination.bucketName}'. Is account ${await account()} bootstrapped?`);
            case BucketOwnership.SOMEONE_ELSES_OR_NO_ACCESS:
                throw new Error(`Bucket named '${destination.bucketName}' exists, but not in account ${await account()}. Wrong account?`);
        }
        if (await objectExists(s3, destination.bucketName, destination.objectKey)) {
            this.host.emitMessage(progress_1.EventType.FOUND, `Found ${s3Url}`);
            return;
        }
        // Identify the the bucket encryption type to set the header on upload
        // required for SCP rules denying uploads without encryption header
        let paramsEncryption = {};
        const encryption2 = await bucketInfo.bucketEncryption(s3, destination.bucketName);
        switch (encryption2.type) {
            case 'no_encryption':
                break;
            case 'aes256':
                paramsEncryption = { ServerSideEncryption: 'AES256' };
                break;
            case 'kms':
                // We must include the key ID otherwise S3 will encrypt with the default key
                paramsEncryption = {
                    ServerSideEncryption: 'aws:kms',
                    SSEKMSKeyId: encryption2.kmsKeyId,
                };
                break;
            case 'does_not_exist':
                this.host.emitMessage(progress_1.EventType.DEBUG, `No bucket named '${destination.bucketName}'. Is account ${await account()} bootstrapped?`);
                break;
            case 'access_denied':
                this.host.emitMessage(progress_1.EventType.DEBUG, `Could not read encryption settings of bucket '${destination.bucketName}': uploading with default settings ("cdk bootstrap" to version 9 if your organization's policies prevent a successful upload or to get rid of this message).`);
                break;
        }
        if (this.host.aborted) {
            return;
        }
        const publishFile = this.asset.source.executable ?
            await this.externalPackageFile(this.asset.source.executable) : await this.packageFile(this.asset.source);
        this.host.emitMessage(progress_1.EventType.UPLOAD, `Upload ${s3Url}`);
        const params = Object.assign({}, {
            Bucket: destination.bucketName,
            Key: destination.objectKey,
            Body: fs_1.createReadStream(publishFile.packagedPath),
            ContentType: publishFile.contentType,
        }, paramsEncryption);
        await s3.upload(params).promise();
    }
    async packageFile(source) {
        var _a;
        if (!source.path) {
            throw new Error(`'path' is expected in the File asset source, got: ${JSON.stringify(source)}`);
        }
        const fullPath = path.resolve(this.workDir, source.path);
        if (source.packaging === cloud_assembly_schema_1.FileAssetPackaging.ZIP_DIRECTORY) {
            const contentType = 'application/zip';
            await fs_1.promises.mkdir(this.fileCacheRoot, { recursive: true });
            const packagedPath = path.join(this.fileCacheRoot, `${this.asset.id.assetId}.zip`);
            if (await fs_extra_1.pathExists(packagedPath)) {
                this.host.emitMessage(progress_1.EventType.CACHED, `From cache ${path}`);
                return { packagedPath, contentType };
            }
            this.host.emitMessage(progress_1.EventType.BUILD, `Zip ${fullPath} -> ${path}`);
            await archive_1.zipDirectory(fullPath, packagedPath);
            return { packagedPath, contentType };
        }
        else {
            const contentType = (_a = mime.getType(fullPath)) !== null && _a !== void 0 ? _a : 'application/octet-stream';
            return { packagedPath: fullPath, contentType };
        }
    }
    async externalPackageFile(executable) {
        this.host.emitMessage(progress_1.EventType.BUILD, `Building asset source using command: '${executable}'`);
        return {
            packagedPath: (await shell_1.shell(executable, { quiet: true })).trim(),
            contentType: 'application/zip',
        };
    }
}
exports.FileAssetHandler = FileAssetHandler;
var BucketOwnership;
(function (BucketOwnership) {
    BucketOwnership[BucketOwnership["DOES_NOT_EXIST"] = 0] = "DOES_NOT_EXIST";
    BucketOwnership[BucketOwnership["MINE"] = 1] = "MINE";
    BucketOwnership[BucketOwnership["SOMEONE_ELSES_OR_NO_ACCESS"] = 2] = "SOMEONE_ELSES_OR_NO_ACCESS";
})(BucketOwnership || (BucketOwnership = {}));
async function objectExists(s3, bucket, key) {
    /*
     * The object existence check here refrains from using the `headObject` operation because this
     * would create a negative cache entry, making GET-after-PUT eventually consistent. This has been
     * observed to result in CloudFormation issuing "ValidationError: S3 error: Access Denied", for
     * example in https://github.com/aws/aws-cdk/issues/6430.
     *
     * To prevent this, we are instead using the listObjectsV2 call, using the looked up key as the
     * prefix, and limiting results to 1. Since the list operation returns keys ordered by binary
     * UTF-8 representation, the key we are looking for is guaranteed to always be the first match
     * returned if it exists.
     */
    const response = await s3.listObjectsV2({ Bucket: bucket, Prefix: key, MaxKeys: 1 }).promise();
    return response.Contents != null && response.Contents.some(object => object.Key === key);
}
/**
 * Cache for bucket information, so we don't have to keep doing the same calls again and again
 *
 * We scope the lifetime of the cache to the lifetime of the host, so that we don't have to do
 * anything special for tests and yet the cache will live for the entire lifetime of the asset
 * upload session when used by the CLI.
 */
class BucketInformation {
    constructor() {
        this.ownerships = new Map();
        this.encryptions = new Map();
    }
    static for(host) {
        const existing = BucketInformation.caches.get(host);
        if (existing) {
            return existing;
        }
        const fresh = new BucketInformation();
        BucketInformation.caches.set(host, fresh);
        return fresh;
    }
    async bucketOwnership(s3, bucket) {
        return cached(this.ownerships, bucket, () => this._bucketOwnership(s3, bucket));
    }
    async bucketEncryption(s3, bucket) {
        return cached(this.encryptions, bucket, () => this._bucketEncryption(s3, bucket));
    }
    async _bucketOwnership(s3, bucket) {
        try {
            await s3.getBucketLocation({ Bucket: bucket }).promise();
            return BucketOwnership.MINE;
        }
        catch (e) {
            if (e.code === 'NoSuchBucket') {
                return BucketOwnership.DOES_NOT_EXIST;
            }
            if (['AccessDenied', 'AllAccessDisabled'].includes(e.code)) {
                return BucketOwnership.SOMEONE_ELSES_OR_NO_ACCESS;
            }
            throw e;
        }
    }
    async _bucketEncryption(s3, bucket) {
        var _a, _b, _c, _d, _e;
        try {
            const encryption = await s3.getBucketEncryption({ Bucket: bucket }).promise();
            const l = (_c = (_b = (_a = encryption === null || encryption === void 0 ? void 0 : encryption.ServerSideEncryptionConfiguration) === null || _a === void 0 ? void 0 : _a.Rules) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
            if (l > 0) {
                const apply = (_e = (_d = encryption === null || encryption === void 0 ? void 0 : encryption.ServerSideEncryptionConfiguration) === null || _d === void 0 ? void 0 : _d.Rules[0]) === null || _e === void 0 ? void 0 : _e.ApplyServerSideEncryptionByDefault;
                let ssealgo = apply === null || apply === void 0 ? void 0 : apply.SSEAlgorithm;
                if (ssealgo === 'AES256')
                    return { type: 'aes256' };
                if (ssealgo === 'aws:kms')
                    return { type: 'kms', kmsKeyId: apply === null || apply === void 0 ? void 0 : apply.KMSMasterKeyID };
            }
            return { type: 'no_encryption' };
        }
        catch (e) {
            if (e.code === 'NoSuchBucket') {
                return { type: 'does_not_exist' };
            }
            if (e.code === 'ServerSideEncryptionConfigurationNotFoundError') {
                return { type: 'no_encryption' };
            }
            if (['AccessDenied', 'AllAccessDisabled'].includes(e.code)) {
                return { type: 'access_denied' };
            }
            return { type: 'no_encryption' };
        }
    }
}
BucketInformation.caches = new WeakMap();
async function cached(cache, key, factory) {
    if (cache.has(key)) {
        return cache.get(key);
    }
    const fresh = await factory(key);
    cache.set(key, fresh);
    return fresh;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJmaWxlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwyQkFBc0Q7QUFDdEQsNkJBQTZCO0FBQzdCLDBFQUFnRjtBQUNoRiw2QkFBNkI7QUFFN0IsNkNBQTJDO0FBQzNDLHdDQUEwQztBQUUxQywwQ0FBeUM7QUFDekMsa0RBQXlEO0FBQ3pELG9DQUFpQztBQUVqQyxNQUFhLGdCQUFnQjtJQUczQixZQUNtQixPQUFlLEVBQ2YsS0FBd0IsRUFDeEIsSUFBa0I7UUFGbEIsWUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUNmLFVBQUssR0FBTCxLQUFLLENBQW1CO1FBQ3hCLFNBQUksR0FBSixJQUFJLENBQWM7UUFDbkMsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRU0sS0FBSyxDQUFDLE9BQU87UUFDbEIsTUFBTSxXQUFXLEdBQUcsTUFBTSxxQ0FBc0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hGLE1BQU0sS0FBSyxHQUFHLFFBQVEsV0FBVyxDQUFDLFVBQVUsSUFBSSxXQUFXLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDeEUsTUFBTSxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDckQsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsb0JBQVMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBRXpELE1BQU0sVUFBVSxHQUFHLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFcEQsbUZBQW1GO1FBQ25GLG9DQUFvQztRQUNwQyxNQUFNLE9BQU8sR0FBRyxLQUFLLElBQUksRUFBRSx3QkFBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsV0FBVyxDQUFDLENBQUMsMENBQUUsU0FBUyxHQUFBLENBQUM7UUFDaEcsUUFBUSxNQUFNLFVBQVUsQ0FBQyxlQUFlLENBQUMsRUFBRSxFQUFFLFdBQVcsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUNwRSxLQUFLLGVBQWUsQ0FBQyxJQUFJO2dCQUN2QixNQUFNO1lBQ1IsS0FBSyxlQUFlLENBQUMsY0FBYztnQkFDakMsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsV0FBVyxDQUFDLFVBQVUsaUJBQWlCLE1BQU0sT0FBTyxFQUFFLGdCQUFnQixDQUFDLENBQUM7WUFDOUcsS0FBSyxlQUFlLENBQUMsMEJBQTBCO2dCQUM3QyxNQUFNLElBQUksS0FBSyxDQUFDLGlCQUFpQixXQUFXLENBQUMsVUFBVSxnQ0FBZ0MsTUFBTSxPQUFPLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztTQUM3SDtRQUVELElBQUksTUFBTSxZQUFZLENBQUMsRUFBRSxFQUFFLFdBQVcsQ0FBQyxVQUFVLEVBQUUsV0FBVyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ3pFLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLG9CQUFTLENBQUMsS0FBSyxFQUFFLFNBQVMsS0FBSyxFQUFFLENBQUMsQ0FBQztZQUN6RCxPQUFPO1NBQ1I7UUFFRCxzRUFBc0U7UUFDdEUsbUVBQW1FO1FBQ25FLElBQUksZ0JBQWdCLEdBQXlCLEVBQUUsQ0FBQztRQUNoRCxNQUFNLFdBQVcsR0FBRyxNQUFNLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUUsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xGLFFBQVEsV0FBVyxDQUFDLElBQUksRUFBRTtZQUN4QixLQUFLLGVBQWU7Z0JBQ2xCLE1BQU07WUFDUixLQUFLLFFBQVE7Z0JBQ1gsZ0JBQWdCLEdBQUcsRUFBRSxvQkFBb0IsRUFBRSxRQUFRLEVBQUUsQ0FBQztnQkFDdEQsTUFBTTtZQUNSLEtBQUssS0FBSztnQkFDUiw0RUFBNEU7Z0JBQzVFLGdCQUFnQixHQUFHO29CQUNqQixvQkFBb0IsRUFBRSxTQUFTO29CQUMvQixXQUFXLEVBQUUsV0FBVyxDQUFDLFFBQVE7aUJBQ2xDLENBQUM7Z0JBQ0YsTUFBTTtZQUNSLEtBQUssZ0JBQWdCO2dCQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxvQkFBUyxDQUFDLEtBQUssRUFBRSxvQkFBb0IsV0FBVyxDQUFDLFVBQVUsaUJBQWlCLE1BQU0sT0FBTyxFQUFFLGdCQUFnQixDQUFDLENBQUM7Z0JBQ25JLE1BQU07WUFDUixLQUFLLGVBQWU7Z0JBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLG9CQUFTLENBQUMsS0FBSyxFQUFFLGlEQUFpRCxXQUFXLENBQUMsVUFBVSw4SkFBOEosQ0FBQyxDQUFDO2dCQUM5USxNQUFNO1NBQ1Q7UUFFRCxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQUUsT0FBTztTQUFFO1FBQ2xDLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2hELE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUUzRyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxvQkFBUyxDQUFDLE1BQU0sRUFBRSxVQUFVLEtBQUssRUFBRSxDQUFDLENBQUM7UUFFM0QsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUU7WUFDL0IsTUFBTSxFQUFFLFdBQVcsQ0FBQyxVQUFVO1lBQzlCLEdBQUcsRUFBRSxXQUFXLENBQUMsU0FBUztZQUMxQixJQUFJLEVBQUUscUJBQWdCLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQztZQUNoRCxXQUFXLEVBQUUsV0FBVyxDQUFDLFdBQVc7U0FDckMsRUFDRCxnQkFBZ0IsQ0FBQyxDQUFDO1FBRWxCLE1BQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNwQyxDQUFDO0lBRU8sS0FBSyxDQUFDLFdBQVcsQ0FBQyxNQUFrQjs7UUFDMUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUU7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxxREFBcUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDaEc7UUFFRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXpELElBQUksTUFBTSxDQUFDLFNBQVMsS0FBSywwQ0FBa0IsQ0FBQyxhQUFhLEVBQUU7WUFDekQsTUFBTSxXQUFXLEdBQUcsaUJBQWlCLENBQUM7WUFFdEMsTUFBTSxhQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUN4RCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxDQUFDO1lBRW5GLElBQUksTUFBTSxxQkFBVSxDQUFDLFlBQVksQ0FBQyxFQUFFO2dCQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxvQkFBUyxDQUFDLE1BQU0sRUFBRSxjQUFjLElBQUksRUFBRSxDQUFDLENBQUM7Z0JBQzlELE9BQU8sRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFFLENBQUM7YUFDdEM7WUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxvQkFBUyxDQUFDLEtBQUssRUFBRSxPQUFPLFFBQVEsT0FBTyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQ3JFLE1BQU0sc0JBQVksQ0FBQyxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUM7WUFDM0MsT0FBTyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsQ0FBQztTQUN0QzthQUFNO1lBQ0wsTUFBTSxXQUFXLFNBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsbUNBQUksMEJBQTBCLENBQUM7WUFDekUsT0FBTyxFQUFFLFlBQVksRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLENBQUM7U0FDaEQ7SUFDSCxDQUFDO0lBRU8sS0FBSyxDQUFDLG1CQUFtQixDQUFDLFVBQW9CO1FBQ3BELElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLG9CQUFTLENBQUMsS0FBSyxFQUFFLHlDQUF5QyxVQUFVLEdBQUcsQ0FBQyxDQUFDO1FBRS9GLE9BQU87WUFDTCxZQUFZLEVBQUUsQ0FBQyxNQUFNLGFBQUssQ0FBQyxVQUFVLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRTtZQUMvRCxXQUFXLEVBQUUsaUJBQWlCO1NBQy9CLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUFoSEQsNENBZ0hDO0FBRUQsSUFBSyxlQUlKO0FBSkQsV0FBSyxlQUFlO0lBQ2xCLHlFQUFjLENBQUE7SUFDZCxxREFBSSxDQUFBO0lBQ0osaUdBQTBCLENBQUE7QUFDNUIsQ0FBQyxFQUpJLGVBQWUsS0FBZixlQUFlLFFBSW5CO0FBVUQsS0FBSyxVQUFVLFlBQVksQ0FBQyxFQUFVLEVBQUUsTUFBYyxFQUFFLEdBQVc7SUFDakU7Ozs7Ozs7Ozs7T0FVRztJQUNILE1BQU0sUUFBUSxHQUFHLE1BQU0sRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUMvRixPQUFPLFFBQVEsQ0FBQyxRQUFRLElBQUksSUFBSSxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQztBQUMzRixDQUFDO0FBcUJEOzs7Ozs7R0FNRztBQUNILE1BQU0saUJBQWlCO0lBZXJCO1FBSGlCLGVBQVUsR0FBRyxJQUFJLEdBQUcsRUFBMkIsQ0FBQztRQUNoRCxnQkFBVyxHQUFHLElBQUksR0FBRyxFQUE0QixDQUFDO0lBR25FLENBQUM7SUFmTSxNQUFNLENBQUMsR0FBRyxDQUFDLElBQWtCO1FBQ2xDLE1BQU0sUUFBUSxHQUFHLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDcEQsSUFBSSxRQUFRLEVBQUU7WUFBRSxPQUFPLFFBQVEsQ0FBQztTQUFFO1FBRWxDLE1BQU0sS0FBSyxHQUFHLElBQUksaUJBQWlCLEVBQUUsQ0FBQztRQUN0QyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUMxQyxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFVTSxLQUFLLENBQUMsZUFBZSxDQUFDLEVBQVUsRUFBRSxNQUFjO1FBQ3JELE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNsRixDQUFDO0lBRU0sS0FBSyxDQUFDLGdCQUFnQixDQUFDLEVBQVUsRUFBRSxNQUFjO1FBQ3RELE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNwRixDQUFDO0lBRU8sS0FBSyxDQUFDLGdCQUFnQixDQUFDLEVBQVUsRUFBRSxNQUFjO1FBQ3ZELElBQUk7WUFDRixNQUFNLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3pELE9BQU8sZUFBZSxDQUFDLElBQUksQ0FBQztTQUM3QjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLGNBQWMsRUFBRTtnQkFBRSxPQUFPLGVBQWUsQ0FBQyxjQUFjLENBQUM7YUFBRTtZQUN6RSxJQUFJLENBQUMsY0FBYyxFQUFFLG1CQUFtQixDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFBRSxPQUFPLGVBQWUsQ0FBQywwQkFBMEIsQ0FBQzthQUFFO1lBQ2xILE1BQU0sQ0FBQyxDQUFDO1NBQ1Q7SUFDSCxDQUFDO0lBRU8sS0FBSyxDQUFDLGlCQUFpQixDQUFDLEVBQVUsRUFBRSxNQUFjOztRQUN4RCxJQUFJO1lBQ0YsTUFBTSxVQUFVLEdBQUcsTUFBTSxFQUFFLENBQUMsbUJBQW1CLENBQUMsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUM5RSxNQUFNLENBQUMscUJBQUcsVUFBVSxhQUFWLFVBQVUsdUJBQVYsVUFBVSxDQUFFLGlDQUFpQywwQ0FBRSxLQUFLLDBDQUFFLE1BQU0sbUNBQUksQ0FBQyxDQUFDO1lBQzVFLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDVCxNQUFNLEtBQUssZUFBRyxVQUFVLGFBQVYsVUFBVSx1QkFBVixVQUFVLENBQUUsaUNBQWlDLDBDQUFFLEtBQUssQ0FBQyxDQUFDLDJDQUFHLGtDQUFrQyxDQUFDO2dCQUMxRyxJQUFJLE9BQU8sR0FBRyxLQUFLLGFBQUwsS0FBSyx1QkFBTCxLQUFLLENBQUUsWUFBWSxDQUFDO2dCQUNsQyxJQUFJLE9BQU8sS0FBSyxRQUFRO29CQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLENBQUM7Z0JBQ3BELElBQUksT0FBTyxLQUFLLFNBQVM7b0JBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLEtBQUssYUFBTCxLQUFLLHVCQUFMLEtBQUssQ0FBRSxjQUFjLEVBQUUsQ0FBQzthQUNwRjtZQUNELE9BQU8sRUFBRSxJQUFJLEVBQUUsZUFBZSxFQUFFLENBQUM7U0FDbEM7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxjQUFjLEVBQUU7Z0JBQzdCLE9BQU8sRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsQ0FBQzthQUNuQztZQUNELElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxnREFBZ0QsRUFBRTtnQkFDL0QsT0FBTyxFQUFFLElBQUksRUFBRSxlQUFlLEVBQUUsQ0FBQzthQUNsQztZQUVELElBQUksQ0FBQyxjQUFjLEVBQUUsbUJBQW1CLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUMxRCxPQUFPLEVBQUUsSUFBSSxFQUFFLGVBQWUsRUFBRSxDQUFDO2FBQ2xDO1lBQ0QsT0FBTyxFQUFFLElBQUksRUFBRSxlQUFlLEVBQUUsQ0FBQztTQUNsQztJQUNILENBQUM7O0FBbkR1Qix3QkFBTSxHQUFHLElBQUksT0FBTyxFQUFtQyxDQUFDO0FBc0RsRixLQUFLLFVBQVUsTUFBTSxDQUFPLEtBQWdCLEVBQUUsR0FBTSxFQUFFLE9BQTZCO0lBQ2pGLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUNsQixPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFFLENBQUM7S0FDeEI7SUFFRCxNQUFNLEtBQUssR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN0QixPQUFPLEtBQUssQ0FBQztBQUNmLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVSZWFkU3RyZWFtLCBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBGaWxlQXNzZXRQYWNrYWdpbmcsIEZpbGVTb3VyY2UgfSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgbWltZSBmcm9tICdtaW1lJztcbmltcG9ydCB7IEZpbGVNYW5pZmVzdEVudHJ5IH0gZnJvbSAnLi4vLi4vYXNzZXQtbWFuaWZlc3QnO1xuaW1wb3J0IHsgRXZlbnRUeXBlIH0gZnJvbSAnLi4vLi4vcHJvZ3Jlc3MnO1xuaW1wb3J0IHsgemlwRGlyZWN0b3J5IH0gZnJvbSAnLi4vYXJjaGl2ZSc7XG5pbXBvcnQgeyBJQXNzZXRIYW5kbGVyLCBJSGFuZGxlckhvc3QgfSBmcm9tICcuLi9hc3NldC1oYW5kbGVyJztcbmltcG9ydCB7IHBhdGhFeGlzdHMgfSBmcm9tICcuLi9mcy1leHRyYSc7XG5pbXBvcnQgeyByZXBsYWNlQXdzUGxhY2Vob2xkZXJzIH0gZnJvbSAnLi4vcGxhY2Vob2xkZXJzJztcbmltcG9ydCB7IHNoZWxsIH0gZnJvbSAnLi4vc2hlbGwnO1xuXG5leHBvcnQgY2xhc3MgRmlsZUFzc2V0SGFuZGxlciBpbXBsZW1lbnRzIElBc3NldEhhbmRsZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGZpbGVDYWNoZVJvb3Q6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHdvcmtEaXI6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFzc2V0OiBGaWxlTWFuaWZlc3RFbnRyeSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGhvc3Q6IElIYW5kbGVySG9zdCkge1xuICAgIHRoaXMuZmlsZUNhY2hlUm9vdCA9IHBhdGguam9pbih3b3JrRGlyLCAnLmNhY2hlJyk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcHVibGlzaCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IGF3YWl0IHJlcGxhY2VBd3NQbGFjZWhvbGRlcnModGhpcy5hc3NldC5kZXN0aW5hdGlvbiwgdGhpcy5ob3N0LmF3cyk7XG4gICAgY29uc3QgczNVcmwgPSBgczM6Ly8ke2Rlc3RpbmF0aW9uLmJ1Y2tldE5hbWV9LyR7ZGVzdGluYXRpb24ub2JqZWN0S2V5fWA7XG4gICAgY29uc3QgczMgPSBhd2FpdCB0aGlzLmhvc3QuYXdzLnMzQ2xpZW50KGRlc3RpbmF0aW9uKTtcbiAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkNIRUNLLCBgQ2hlY2sgJHtzM1VybH1gKTtcblxuICAgIGNvbnN0IGJ1Y2tldEluZm8gPSBCdWNrZXRJbmZvcm1hdGlvbi5mb3IodGhpcy5ob3N0KTtcblxuICAgIC8vIEEgdGh1bmsgZm9yIGRlc2NyaWJpbmcgdGhlIGN1cnJlbnQgYWNjb3VudC4gVXNlZCB3aGVuIHdlIG5lZWQgdG8gZm9ybWF0IGFuIGVycm9yXG4gICAgLy8gbWVzc2FnZSwgbm90IGluIHRoZSBzdWNjZXNzIGNhc2UuXG4gICAgY29uc3QgYWNjb3VudCA9IGFzeW5jICgpID0+IChhd2FpdCB0aGlzLmhvc3QuYXdzLmRpc2NvdmVyVGFyZ2V0QWNjb3VudChkZXN0aW5hdGlvbikpPy5hY2NvdW50SWQ7XG4gICAgc3dpdGNoIChhd2FpdCBidWNrZXRJbmZvLmJ1Y2tldE93bmVyc2hpcChzMywgZGVzdGluYXRpb24uYnVja2V0TmFtZSkpIHtcbiAgICAgIGNhc2UgQnVja2V0T3duZXJzaGlwLk1JTkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCdWNrZXRPd25lcnNoaXAuRE9FU19OT1RfRVhJU1Q6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gYnVja2V0IG5hbWVkICcke2Rlc3RpbmF0aW9uLmJ1Y2tldE5hbWV9Jy4gSXMgYWNjb3VudCAke2F3YWl0IGFjY291bnQoKX0gYm9vdHN0cmFwcGVkP2ApO1xuICAgICAgY2FzZSBCdWNrZXRPd25lcnNoaXAuU09NRU9ORV9FTFNFU19PUl9OT19BQ0NFU1M6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQnVja2V0IG5hbWVkICcke2Rlc3RpbmF0aW9uLmJ1Y2tldE5hbWV9JyBleGlzdHMsIGJ1dCBub3QgaW4gYWNjb3VudCAke2F3YWl0IGFjY291bnQoKX0uIFdyb25nIGFjY291bnQ/YCk7XG4gICAgfVxuXG4gICAgaWYgKGF3YWl0IG9iamVjdEV4aXN0cyhzMywgZGVzdGluYXRpb24uYnVja2V0TmFtZSwgZGVzdGluYXRpb24ub2JqZWN0S2V5KSkge1xuICAgICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5GT1VORCwgYEZvdW5kICR7czNVcmx9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWRlbnRpZnkgdGhlIHRoZSBidWNrZXQgZW5jcnlwdGlvbiB0eXBlIHRvIHNldCB0aGUgaGVhZGVyIG9uIHVwbG9hZFxuICAgIC8vIHJlcXVpcmVkIGZvciBTQ1AgcnVsZXMgZGVueWluZyB1cGxvYWRzIHdpdGhvdXQgZW5jcnlwdGlvbiBoZWFkZXJcbiAgICBsZXQgcGFyYW1zRW5jcnlwdGlvbjoge1tpbmRleDogc3RyaW5nXTphbnl9PSB7fTtcbiAgICBjb25zdCBlbmNyeXB0aW9uMiA9IGF3YWl0IGJ1Y2tldEluZm8uYnVja2V0RW5jcnlwdGlvbihzMywgZGVzdGluYXRpb24uYnVja2V0TmFtZSk7XG4gICAgc3dpdGNoIChlbmNyeXB0aW9uMi50eXBlKSB7XG4gICAgICBjYXNlICdub19lbmNyeXB0aW9uJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhZXMyNTYnOlxuICAgICAgICBwYXJhbXNFbmNyeXB0aW9uID0geyBTZXJ2ZXJTaWRlRW5jcnlwdGlvbjogJ0FFUzI1NicgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdrbXMnOlxuICAgICAgICAvLyBXZSBtdXN0IGluY2x1ZGUgdGhlIGtleSBJRCBvdGhlcndpc2UgUzMgd2lsbCBlbmNyeXB0IHdpdGggdGhlIGRlZmF1bHQga2V5XG4gICAgICAgIHBhcmFtc0VuY3J5cHRpb24gPSB7XG4gICAgICAgICAgU2VydmVyU2lkZUVuY3J5cHRpb246ICdhd3M6a21zJyxcbiAgICAgICAgICBTU0VLTVNLZXlJZDogZW5jcnlwdGlvbjIua21zS2V5SWQsXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZG9lc19ub3RfZXhpc3QnOlxuICAgICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkRFQlVHLCBgTm8gYnVja2V0IG5hbWVkICcke2Rlc3RpbmF0aW9uLmJ1Y2tldE5hbWV9Jy4gSXMgYWNjb3VudCAke2F3YWl0IGFjY291bnQoKX0gYm9vdHN0cmFwcGVkP2ApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2FjY2Vzc19kZW5pZWQnOlxuICAgICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkRFQlVHLCBgQ291bGQgbm90IHJlYWQgZW5jcnlwdGlvbiBzZXR0aW5ncyBvZiBidWNrZXQgJyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0nOiB1cGxvYWRpbmcgd2l0aCBkZWZhdWx0IHNldHRpbmdzIChcImNkayBib290c3RyYXBcIiB0byB2ZXJzaW9uIDkgaWYgeW91ciBvcmdhbml6YXRpb24ncyBwb2xpY2llcyBwcmV2ZW50IGEgc3VjY2Vzc2Z1bCB1cGxvYWQgb3IgdG8gZ2V0IHJpZCBvZiB0aGlzIG1lc3NhZ2UpLmApO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0LmFib3J0ZWQpIHsgcmV0dXJuOyB9XG4gICAgY29uc3QgcHVibGlzaEZpbGUgPSB0aGlzLmFzc2V0LnNvdXJjZS5leGVjdXRhYmxlID9cbiAgICAgIGF3YWl0IHRoaXMuZXh0ZXJuYWxQYWNrYWdlRmlsZSh0aGlzLmFzc2V0LnNvdXJjZS5leGVjdXRhYmxlKSA6IGF3YWl0IHRoaXMucGFja2FnZUZpbGUodGhpcy5hc3NldC5zb3VyY2UpO1xuXG4gICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5VUExPQUQsIGBVcGxvYWQgJHtzM1VybH1gKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgIEJ1Y2tldDogZGVzdGluYXRpb24uYnVja2V0TmFtZSxcbiAgICAgIEtleTogZGVzdGluYXRpb24ub2JqZWN0S2V5LFxuICAgICAgQm9keTogY3JlYXRlUmVhZFN0cmVhbShwdWJsaXNoRmlsZS5wYWNrYWdlZFBhdGgpLFxuICAgICAgQ29udGVudFR5cGU6IHB1Ymxpc2hGaWxlLmNvbnRlbnRUeXBlLFxuICAgIH0sXG4gICAgcGFyYW1zRW5jcnlwdGlvbik7XG5cbiAgICBhd2FpdCBzMy51cGxvYWQocGFyYW1zKS5wcm9taXNlKCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHBhY2thZ2VGaWxlKHNvdXJjZTogRmlsZVNvdXJjZSk6IFByb21pc2U8UGFja2FnZWRGaWxlQXNzZXQ+IHtcbiAgICBpZiAoIXNvdXJjZS5wYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCdwYXRoJyBpcyBleHBlY3RlZCBpbiB0aGUgRmlsZSBhc3NldCBzb3VyY2UsIGdvdDogJHtKU09OLnN0cmluZ2lmeShzb3VyY2UpfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMud29ya0Rpciwgc291cmNlLnBhdGgpO1xuXG4gICAgaWYgKHNvdXJjZS5wYWNrYWdpbmcgPT09IEZpbGVBc3NldFBhY2thZ2luZy5aSVBfRElSRUNUT1JZKSB7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi96aXAnO1xuXG4gICAgICBhd2FpdCBmcy5ta2Rpcih0aGlzLmZpbGVDYWNoZVJvb3QsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgY29uc3QgcGFja2FnZWRQYXRoID0gcGF0aC5qb2luKHRoaXMuZmlsZUNhY2hlUm9vdCwgYCR7dGhpcy5hc3NldC5pZC5hc3NldElkfS56aXBgKTtcblxuICAgICAgaWYgKGF3YWl0IHBhdGhFeGlzdHMocGFja2FnZWRQYXRoKSkge1xuICAgICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkNBQ0hFRCwgYEZyb20gY2FjaGUgJHtwYXRofWApO1xuICAgICAgICByZXR1cm4geyBwYWNrYWdlZFBhdGgsIGNvbnRlbnRUeXBlIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuQlVJTEQsIGBaaXAgJHtmdWxsUGF0aH0gLT4gJHtwYXRofWApO1xuICAgICAgYXdhaXQgemlwRGlyZWN0b3J5KGZ1bGxQYXRoLCBwYWNrYWdlZFBhdGgpO1xuICAgICAgcmV0dXJuIHsgcGFja2FnZWRQYXRoLCBjb250ZW50VHlwZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IG1pbWUuZ2V0VHlwZShmdWxsUGF0aCkgPz8gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgICByZXR1cm4geyBwYWNrYWdlZFBhdGg6IGZ1bGxQYXRoLCBjb250ZW50VHlwZSB9O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZXh0ZXJuYWxQYWNrYWdlRmlsZShleGVjdXRhYmxlOiBzdHJpbmdbXSk6IFByb21pc2U8UGFja2FnZWRGaWxlQXNzZXQ+IHtcbiAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkJVSUxELCBgQnVpbGRpbmcgYXNzZXQgc291cmNlIHVzaW5nIGNvbW1hbmQ6ICcke2V4ZWN1dGFibGV9J2ApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhY2thZ2VkUGF0aDogKGF3YWl0IHNoZWxsKGV4ZWN1dGFibGUsIHsgcXVpZXQ6IHRydWUgfSkpLnRyaW0oKSxcbiAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vemlwJyxcbiAgICB9O1xuICB9XG59XG5cbmVudW0gQnVja2V0T3duZXJzaGlwIHtcbiAgRE9FU19OT1RfRVhJU1QsXG4gIE1JTkUsXG4gIFNPTUVPTkVfRUxTRVNfT1JfTk9fQUNDRVNTXG59XG5cbnR5cGUgQnVja2V0RW5jcnlwdGlvbiA9XG4gIHwgeyByZWFkb25seSB0eXBlOiAnbm9fZW5jcnlwdGlvbicgfVxuICB8IHsgcmVhZG9ubHkgdHlwZTogJ2FlczI1NicgfVxuICB8IHsgcmVhZG9ubHkgdHlwZTogJ2ttcyc7IHJlYWRvbmx5IGttc0tleUlkPzogc3RyaW5nIH1cbiAgfCB7IHJlYWRvbmx5IHR5cGU6ICdhY2Nlc3NfZGVuaWVkJyB9XG4gIHwgeyByZWFkb25seSB0eXBlOiAnZG9lc19ub3RfZXhpc3QnIH1cbiAgO1xuXG5hc3luYyBmdW5jdGlvbiBvYmplY3RFeGlzdHMoczM6IEFXUy5TMywgYnVja2V0OiBzdHJpbmcsIGtleTogc3RyaW5nKSB7XG4gIC8qXG4gICAqIFRoZSBvYmplY3QgZXhpc3RlbmNlIGNoZWNrIGhlcmUgcmVmcmFpbnMgZnJvbSB1c2luZyB0aGUgYGhlYWRPYmplY3RgIG9wZXJhdGlvbiBiZWNhdXNlIHRoaXNcbiAgICogd291bGQgY3JlYXRlIGEgbmVnYXRpdmUgY2FjaGUgZW50cnksIG1ha2luZyBHRVQtYWZ0ZXItUFVUIGV2ZW50dWFsbHkgY29uc2lzdGVudC4gVGhpcyBoYXMgYmVlblxuICAgKiBvYnNlcnZlZCB0byByZXN1bHQgaW4gQ2xvdWRGb3JtYXRpb24gaXNzdWluZyBcIlZhbGlkYXRpb25FcnJvcjogUzMgZXJyb3I6IEFjY2VzcyBEZW5pZWRcIiwgZm9yXG4gICAqIGV4YW1wbGUgaW4gaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy82NDMwLlxuICAgKlxuICAgKiBUbyBwcmV2ZW50IHRoaXMsIHdlIGFyZSBpbnN0ZWFkIHVzaW5nIHRoZSBsaXN0T2JqZWN0c1YyIGNhbGwsIHVzaW5nIHRoZSBsb29rZWQgdXAga2V5IGFzIHRoZVxuICAgKiBwcmVmaXgsIGFuZCBsaW1pdGluZyByZXN1bHRzIHRvIDEuIFNpbmNlIHRoZSBsaXN0IG9wZXJhdGlvbiByZXR1cm5zIGtleXMgb3JkZXJlZCBieSBiaW5hcnlcbiAgICogVVRGLTggcmVwcmVzZW50YXRpb24sIHRoZSBrZXkgd2UgYXJlIGxvb2tpbmcgZm9yIGlzIGd1YXJhbnRlZWQgdG8gYWx3YXlzIGJlIHRoZSBmaXJzdCBtYXRjaFxuICAgKiByZXR1cm5lZCBpZiBpdCBleGlzdHMuXG4gICAqL1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHMzLmxpc3RPYmplY3RzVjIoeyBCdWNrZXQ6IGJ1Y2tldCwgUHJlZml4OiBrZXksIE1heEtleXM6IDEgfSkucHJvbWlzZSgpO1xuICByZXR1cm4gcmVzcG9uc2UuQ29udGVudHMgIT0gbnVsbCAmJiByZXNwb25zZS5Db250ZW50cy5zb21lKG9iamVjdCA9PiBvYmplY3QuS2V5ID09PSBrZXkpO1xufVxuXG5cbi8qKlxuICogQSBwYWNrYWdlZCBhc3NldCB3aGljaCBjYW4gYmUgdXBsb2FkZWQgKGVpdGhlciBhIHNpbmdsZSBmaWxlIG9yIGRpcmVjdG9yeSlcbiAqL1xuaW50ZXJmYWNlIFBhY2thZ2VkRmlsZUFzc2V0IHtcbiAgLyoqXG4gICAqIFBhdGggb2YgdGhlIGZpbGUgb3IgZGlyZWN0b3J5XG4gICAqL1xuICByZWFkb25seSBwYWNrYWdlZFBhdGg6IHN0cmluZztcblxuICAvKipcbiAgICogQ29udGVudCB0eXBlIHRvIGJlIGFkZGVkIGluIHRoZSBTMyB1cGxvYWQgYWN0aW9uXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gY29udGVudCB0eXBlXG4gICAqL1xuICByZWFkb25seSBjb250ZW50VHlwZT86IHN0cmluZztcbn1cblxuXG4vKipcbiAqIENhY2hlIGZvciBidWNrZXQgaW5mb3JtYXRpb24sIHNvIHdlIGRvbid0IGhhdmUgdG8ga2VlcCBkb2luZyB0aGUgc2FtZSBjYWxscyBhZ2FpbiBhbmQgYWdhaW5cbiAqXG4gKiBXZSBzY29wZSB0aGUgbGlmZXRpbWUgb2YgdGhlIGNhY2hlIHRvIHRoZSBsaWZldGltZSBvZiB0aGUgaG9zdCwgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGRvXG4gKiBhbnl0aGluZyBzcGVjaWFsIGZvciB0ZXN0cyBhbmQgeWV0IHRoZSBjYWNoZSB3aWxsIGxpdmUgZm9yIHRoZSBlbnRpcmUgbGlmZXRpbWUgb2YgdGhlIGFzc2V0XG4gKiB1cGxvYWQgc2Vzc2lvbiB3aGVuIHVzZWQgYnkgdGhlIENMSS5cbiAqL1xuY2xhc3MgQnVja2V0SW5mb3JtYXRpb24ge1xuICBwdWJsaWMgc3RhdGljIGZvcihob3N0OiBJSGFuZGxlckhvc3QpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IEJ1Y2tldEluZm9ybWF0aW9uLmNhY2hlcy5nZXQoaG9zdCk7XG4gICAgaWYgKGV4aXN0aW5nKSB7IHJldHVybiBleGlzdGluZzsgfVxuXG4gICAgY29uc3QgZnJlc2ggPSBuZXcgQnVja2V0SW5mb3JtYXRpb24oKTtcbiAgICBCdWNrZXRJbmZvcm1hdGlvbi5jYWNoZXMuc2V0KGhvc3QsIGZyZXNoKTtcbiAgICByZXR1cm4gZnJlc2g7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBjYWNoZXMgPSBuZXcgV2Vha01hcDxJSGFuZGxlckhvc3QsIEJ1Y2tldEluZm9ybWF0aW9uPigpO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgb3duZXJzaGlwcyA9IG5ldyBNYXA8c3RyaW5nLCBCdWNrZXRPd25lcnNoaXA+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgZW5jcnlwdGlvbnMgPSBuZXcgTWFwPHN0cmluZywgQnVja2V0RW5jcnlwdGlvbj4oKTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGJ1Y2tldE93bmVyc2hpcChzMzogQVdTLlMzLCBidWNrZXQ6IHN0cmluZyk6IFByb21pc2U8QnVja2V0T3duZXJzaGlwPiB7XG4gICAgcmV0dXJuIGNhY2hlZCh0aGlzLm93bmVyc2hpcHMsIGJ1Y2tldCwgKCkgPT4gdGhpcy5fYnVja2V0T3duZXJzaGlwKHMzLCBidWNrZXQpKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBidWNrZXRFbmNyeXB0aW9uKHMzOiBBV1MuUzMsIGJ1Y2tldDogc3RyaW5nKTogUHJvbWlzZTxCdWNrZXRFbmNyeXB0aW9uPiB7XG4gICAgcmV0dXJuIGNhY2hlZCh0aGlzLmVuY3J5cHRpb25zLCBidWNrZXQsICgpID0+IHRoaXMuX2J1Y2tldEVuY3J5cHRpb24oczMsIGJ1Y2tldCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfYnVja2V0T3duZXJzaGlwKHMzOiBBV1MuUzMsIGJ1Y2tldDogc3RyaW5nKTogUHJvbWlzZTxCdWNrZXRPd25lcnNoaXA+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgczMuZ2V0QnVja2V0TG9jYXRpb24oeyBCdWNrZXQ6IGJ1Y2tldCB9KS5wcm9taXNlKCk7XG4gICAgICByZXR1cm4gQnVja2V0T3duZXJzaGlwLk1JTkU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuY29kZSA9PT0gJ05vU3VjaEJ1Y2tldCcpIHsgcmV0dXJuIEJ1Y2tldE93bmVyc2hpcC5ET0VTX05PVF9FWElTVDsgfVxuICAgICAgaWYgKFsnQWNjZXNzRGVuaWVkJywgJ0FsbEFjY2Vzc0Rpc2FibGVkJ10uaW5jbHVkZXMoZS5jb2RlKSkgeyByZXR1cm4gQnVja2V0T3duZXJzaGlwLlNPTUVPTkVfRUxTRVNfT1JfTk9fQUNDRVNTOyB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2J1Y2tldEVuY3J5cHRpb24oczM6IEFXUy5TMywgYnVja2V0OiBzdHJpbmcpOiBQcm9taXNlPEJ1Y2tldEVuY3J5cHRpb24+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZW5jcnlwdGlvbiA9IGF3YWl0IHMzLmdldEJ1Y2tldEVuY3J5cHRpb24oeyBCdWNrZXQ6IGJ1Y2tldCB9KS5wcm9taXNlKCk7XG4gICAgICBjb25zdCBsID0gZW5jcnlwdGlvbj8uU2VydmVyU2lkZUVuY3J5cHRpb25Db25maWd1cmF0aW9uPy5SdWxlcz8ubGVuZ3RoID8/IDA7XG4gICAgICBpZiAobCA+IDApIHtcbiAgICAgICAgY29uc3QgYXBwbHkgPSBlbmNyeXB0aW9uPy5TZXJ2ZXJTaWRlRW5jcnlwdGlvbkNvbmZpZ3VyYXRpb24/LlJ1bGVzWzBdPy5BcHBseVNlcnZlclNpZGVFbmNyeXB0aW9uQnlEZWZhdWx0O1xuICAgICAgICBsZXQgc3NlYWxnbyA9IGFwcGx5Py5TU0VBbGdvcml0aG07XG4gICAgICAgIGlmIChzc2VhbGdvID09PSAnQUVTMjU2JykgcmV0dXJuIHsgdHlwZTogJ2FlczI1NicgfTtcbiAgICAgICAgaWYgKHNzZWFsZ28gPT09ICdhd3M6a21zJykgcmV0dXJuIHsgdHlwZTogJ2ttcycsIGttc0tleUlkOiBhcHBseT8uS01TTWFzdGVyS2V5SUQgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHR5cGU6ICdub19lbmNyeXB0aW9uJyB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLmNvZGUgPT09ICdOb1N1Y2hCdWNrZXQnKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdkb2VzX25vdF9leGlzdCcgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlLmNvZGUgPT09ICdTZXJ2ZXJTaWRlRW5jcnlwdGlvbkNvbmZpZ3VyYXRpb25Ob3RGb3VuZEVycm9yJykge1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnbm9fZW5jcnlwdGlvbicgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKFsnQWNjZXNzRGVuaWVkJywgJ0FsbEFjY2Vzc0Rpc2FibGVkJ10uaW5jbHVkZXMoZS5jb2RlKSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnYWNjZXNzX2RlbmllZCcgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHR5cGU6ICdub19lbmNyeXB0aW9uJyB9O1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjYWNoZWQ8QSwgQj4oY2FjaGU6IE1hcDxBLCBCPiwga2V5OiBBLCBmYWN0b3J5OiAoeDogQSkgPT4gUHJvbWlzZTxCPik6IFByb21pc2U8Qj4ge1xuICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSkhO1xuICB9XG5cbiAgY29uc3QgZnJlc2ggPSBhd2FpdCBmYWN0b3J5KGtleSk7XG4gIGNhY2hlLnNldChrZXksIGZyZXNoKTtcbiAgcmV0dXJuIGZyZXNoO1xufSJdfQ==