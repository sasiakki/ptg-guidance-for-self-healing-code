"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const logs_monitor_1 = require("../../../lib/api/logs/logs-monitor");
const aws_1 = require("../../integ/helpers/aws");
const mock_sdk_1 = require("../../util/mock-sdk");
let sdk;
let stderrMock;
let monitor;
beforeEach(() => {
    monitor = new logs_monitor_1.CloudWatchLogEventMonitor(new Date(T100));
    stderrMock = jest.spyOn(process.stderr, 'write').mockImplementation(() => { return true; });
    sdk = new mock_sdk_1.MockSdk();
});
afterAll(() => {
    stderrMock.mockRestore();
    monitor.deactivate();
});
let TIMESTAMP;
let HUMAN_TIME;
beforeAll(() => {
    TIMESTAMP = new Date().getTime();
    HUMAN_TIME = new Date(TIMESTAMP).toLocaleTimeString();
});
test('continue to the next page if it exists', async () => {
    // GIVEN
    sdk.stubCloudWatchLogs({
        filterLogEvents() {
            return {
                events: [event(102, 'message')],
                nextToken: 'some-token',
            };
        },
    });
    monitor.addLogGroups({
        name: 'name',
        account: '11111111111',
        region: 'us-east-1',
    }, sdk, ['loggroup']);
    // WHEN
    monitor.activate();
    // need time for the log processing to occur
    await aws_1.sleep(1000);
    // THEN
    expect(stderrMock).toHaveBeenCalledTimes(2);
    expect(stderrMock.mock.calls[0][0]).toContain(`[${chalk_1.blue('loggroup')}] ${chalk_1.yellow(HUMAN_TIME)} message`);
    expect(stderrMock.mock.calls[1][0]).toContain(`[${chalk_1.blue('loggroup')}] ${chalk_1.yellow(new Date(T100).toLocaleTimeString())} (...messages supressed...)`);
});
const T0 = 1597837230504;
const T100 = T0 + 100 * 1000;
function event(nr, message) {
    return {
        eventId: `${nr}`,
        message,
        timestamp: new Date(T0 * nr * 1000).getTime(),
        ingestionTime: new Date(T0 * nr * 1000).getTime(),
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9ncy1tb25pdG9yLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJsb2dzLW1vbml0b3IudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGlDQUFxQztBQUNyQyxxRUFBK0U7QUFDL0UsaURBQWdEO0FBQ2hELGtEQUE4QztBQUU5QyxJQUFJLEdBQVksQ0FBQztBQUNqQixJQUFJLFVBQTRCLENBQUM7QUFDakMsSUFBSSxPQUFrQyxDQUFDO0FBQ3ZDLFVBQVUsQ0FBQyxHQUFHLEVBQUU7SUFDZCxPQUFPLEdBQUcsSUFBSSx3Q0FBeUIsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3hELFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUMsa0JBQWtCLENBQUMsR0FBRyxFQUFFLEdBQUcsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1RixHQUFHLEdBQUcsSUFBSSxrQkFBTyxFQUFFLENBQUM7QUFDdEIsQ0FBQyxDQUFDLENBQUM7QUFFSCxRQUFRLENBQUMsR0FBRyxFQUFFO0lBQ1osVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3pCLE9BQU8sQ0FBQyxVQUFVLEVBQUUsQ0FBQztBQUN2QixDQUFDLENBQUMsQ0FBQztBQUVILElBQUksU0FBaUIsQ0FBQztBQUN0QixJQUFJLFVBQWtCLENBQUM7QUFFdkIsU0FBUyxDQUFDLEdBQUcsRUFBRTtJQUNiLFNBQVMsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ2pDLFVBQVUsR0FBRyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO0FBQ3hELENBQUMsQ0FBQyxDQUFDO0FBRUgsSUFBSSxDQUFDLHdDQUF3QyxFQUFFLEtBQUssSUFBSSxFQUFFO0lBQ3hELFFBQVE7SUFDUixHQUFHLENBQUMsa0JBQWtCLENBQUM7UUFDckIsZUFBZTtZQUNiLE9BQU87Z0JBQ0wsTUFBTSxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztnQkFDL0IsU0FBUyxFQUFFLFlBQVk7YUFDeEIsQ0FBQztRQUNKLENBQUM7S0FDRixDQUFDLENBQUM7SUFDSCxPQUFPLENBQUMsWUFBWSxDQUNsQjtRQUNFLElBQUksRUFBRSxNQUFNO1FBQ1osT0FBTyxFQUFFLGFBQWE7UUFDdEIsTUFBTSxFQUFFLFdBQVc7S0FDcEIsRUFDRCxHQUFHLEVBQ0gsQ0FBQyxVQUFVLENBQUMsQ0FDYixDQUFDO0lBQ0YsT0FBTztJQUNQLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNuQiw0Q0FBNEM7SUFDNUMsTUFBTSxXQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFbEIsT0FBTztJQUNQLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1QyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQzNDLElBQUksWUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLGNBQU0sQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUN0RCxDQUFDO0lBQ0YsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUMzQyxJQUFJLFlBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxjQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsa0JBQWtCLEVBQUUsQ0FBQyw2QkFBNkIsQ0FDbEcsQ0FBQztBQUNKLENBQUMsQ0FBQyxDQUFDO0FBRUgsTUFBTSxFQUFFLEdBQUcsYUFBYSxDQUFDO0FBQ3pCLE1BQU0sSUFBSSxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDO0FBQzdCLFNBQVMsS0FBSyxDQUFDLEVBQVUsRUFBRSxPQUFlO0lBQ3hDLE9BQU87UUFDTCxPQUFPLEVBQUUsR0FBRyxFQUFFLEVBQUU7UUFDaEIsT0FBTztRQUNQLFNBQVMsRUFBRSxJQUFJLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRTtRQUM3QyxhQUFhLEVBQUUsSUFBSSxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUU7S0FDbEQsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBibHVlLCB5ZWxsb3cgfSBmcm9tICdjaGFsayc7XG5pbXBvcnQgeyBDbG91ZFdhdGNoTG9nRXZlbnRNb25pdG9yIH0gZnJvbSAnLi4vLi4vLi4vbGliL2FwaS9sb2dzL2xvZ3MtbW9uaXRvcic7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4uLy4uL2ludGVnL2hlbHBlcnMvYXdzJztcbmltcG9ydCB7IE1vY2tTZGsgfSBmcm9tICcuLi8uLi91dGlsL21vY2stc2RrJztcblxubGV0IHNkazogTW9ja1NkaztcbmxldCBzdGRlcnJNb2NrOiBqZXN0LlNweUluc3RhbmNlO1xubGV0IG1vbml0b3I6IENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3I7XG5iZWZvcmVFYWNoKCgpID0+IHtcbiAgbW9uaXRvciA9IG5ldyBDbG91ZFdhdGNoTG9nRXZlbnRNb25pdG9yKG5ldyBEYXRlKFQxMDApKTtcbiAgc3RkZXJyTW9jayA9IGplc3Quc3B5T24ocHJvY2Vzcy5zdGRlcnIsICd3cml0ZScpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7IHJldHVybiB0cnVlOyB9KTtcbiAgc2RrID0gbmV3IE1vY2tTZGsoKTtcbn0pO1xuXG5hZnRlckFsbCgoKSA9PiB7XG4gIHN0ZGVyck1vY2subW9ja1Jlc3RvcmUoKTtcbiAgbW9uaXRvci5kZWFjdGl2YXRlKCk7XG59KTtcblxubGV0IFRJTUVTVEFNUDogbnVtYmVyO1xubGV0IEhVTUFOX1RJTUU6IHN0cmluZztcblxuYmVmb3JlQWxsKCgpID0+IHtcbiAgVElNRVNUQU1QID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIEhVTUFOX1RJTUUgPSBuZXcgRGF0ZShUSU1FU1RBTVApLnRvTG9jYWxlVGltZVN0cmluZygpO1xufSk7XG5cbnRlc3QoJ2NvbnRpbnVlIHRvIHRoZSBuZXh0IHBhZ2UgaWYgaXQgZXhpc3RzJywgYXN5bmMgKCkgPT4ge1xuICAvLyBHSVZFTlxuICBzZGsuc3R1YkNsb3VkV2F0Y2hMb2dzKHtcbiAgICBmaWx0ZXJMb2dFdmVudHMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBldmVudHM6IFtldmVudCgxMDIsICdtZXNzYWdlJyldLFxuICAgICAgICBuZXh0VG9rZW46ICdzb21lLXRva2VuJyxcbiAgICAgIH07XG4gICAgfSxcbiAgfSk7XG4gIG1vbml0b3IuYWRkTG9nR3JvdXBzKFxuICAgIHtcbiAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgIGFjY291bnQ6ICcxMTExMTExMTExMScsXG4gICAgICByZWdpb246ICd1cy1lYXN0LTEnLFxuICAgIH0sXG4gICAgc2RrLFxuICAgIFsnbG9nZ3JvdXAnXSxcbiAgKTtcbiAgLy8gV0hFTlxuICBtb25pdG9yLmFjdGl2YXRlKCk7XG4gIC8vIG5lZWQgdGltZSBmb3IgdGhlIGxvZyBwcm9jZXNzaW5nIHRvIG9jY3VyXG4gIGF3YWl0IHNsZWVwKDEwMDApO1xuXG4gIC8vIFRIRU5cbiAgZXhwZWN0KHN0ZGVyck1vY2spLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcbiAgZXhwZWN0KHN0ZGVyck1vY2subW9jay5jYWxsc1swXVswXSkudG9Db250YWluKFxuICAgIGBbJHtibHVlKCdsb2dncm91cCcpfV0gJHt5ZWxsb3coSFVNQU5fVElNRSl9IG1lc3NhZ2VgLFxuICApO1xuICBleHBlY3Qoc3RkZXJyTW9jay5tb2NrLmNhbGxzWzFdWzBdKS50b0NvbnRhaW4oXG4gICAgYFske2JsdWUoJ2xvZ2dyb3VwJyl9XSAke3llbGxvdyhuZXcgRGF0ZShUMTAwKS50b0xvY2FsZVRpbWVTdHJpbmcoKSl9ICguLi5tZXNzYWdlcyBzdXByZXNzZWQuLi4pYCxcbiAgKTtcbn0pO1xuXG5jb25zdCBUMCA9IDE1OTc4MzcyMzA1MDQ7XG5jb25zdCBUMTAwID0gVDAgKyAxMDAgKiAxMDAwO1xuZnVuY3Rpb24gZXZlbnQobnI6IG51bWJlciwgbWVzc2FnZTogc3RyaW5nKTogQVdTLkNsb3VkV2F0Y2hMb2dzLkZpbHRlcmVkTG9nRXZlbnQge1xuICByZXR1cm4ge1xuICAgIGV2ZW50SWQ6IGAke25yfWAsXG4gICAgbWVzc2FnZSxcbiAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKFQwICogbnIgKiAxMDAwKS5nZXRUaW1lKCksXG4gICAgaW5nZXN0aW9uVGltZTogbmV3IERhdGUoVDAgKiBuciAqIDEwMDApLmdldFRpbWUoKSxcbiAgfTtcbn1cbiJdfQ==